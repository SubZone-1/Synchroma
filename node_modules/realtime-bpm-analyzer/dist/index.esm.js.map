{
  "version": 3,
  "sources": ["../src/consts.ts", "../src/utils.ts", "../src/analyzer.ts", "../src/realtime-bpm-analyzer.ts", "../src/index.ts"],
  "sourcesContent": ["export const realtimeBpmProcessorName = 'realtime-bpm-processor';\nexport const startThreshold = 0.95;\nexport const minValidThreshold = 0.3;\nexport const minPeaks = 15;\nexport const thresholdStep = 0.05;\nexport const skipForwardIndexes = 10000;\nexport const offlineLowPassFrequencyValue = 150;\nexport const offlineLowPassQualityValue = 1;\nexport const offlineHighPassFrequencyValue = 100;\nexport const offlineHighPassQualityValue = 1;\n\n", "import * as consts from './consts';\nimport type {Peaks, ValidPeaks, NextIndexPeaks, OnThresholdFunction, AggregateData} from './types';\n\n/**\n * Loop between .9 and minValidThreshold at .3 by default, passoing the threshold to the function\n * @param {OnThresholdFunction} onThreshold Function for each iteration, you must return a boolean, true will exit the loop process\n * @param {number} minValidThreshold minValidThreshold usualy 0.3\n * @param {number} startThreshold startThreshold usualy 0.9\n * @param {number} thresholdStep thresholdStep usuably 0.05\n * @return {Promise<void>}\n */\nexport async function descendingOverThresholds(onThreshold: OnThresholdFunction, minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): Promise<void> {\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    const shouldExit = await onThreshold(threshold);\n    if (shouldExit) {\n      break;\n    }\n  } while (threshold > minValidThreshold);\n}\n\n/**\n * Generate an object with keys as thresholds and will containes validPeaks\n * @param {number} minValidThreshold minValidThreshold usualy 0.3\n * @param {number} startThreshold startThreshold usualy 0.9\n * @param {number} thresholdStep thresholdStep usuably 0.05\n * @return {ValidPeaks} Collection of validPeaks by thresholds\n */\nexport function generateValidPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): ValidPeaks {\n  const object: Record<string, Peaks> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = [];\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Generate an object with keys as thresholds and will containes NextIndexPeaks\n * @return {NextIndexPeaks} Collection of NextIndexPeaks by thresholds\n */\nexport function generateNextIndexPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): NextIndexPeaks {\n  const object: Record<string, number> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = 0;\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\nexport function chunckAggregator(): (pcmData: Float32Array) => AggregateData {\n  const bufferSize = 4096;\n\n  /**\n   * Track the current buffer fill level\n   */\n  let _bytesWritten = 0;\n\n  /**\n   * Create a buffer of fixed size\n   */\n  let buffer: Float32Array = new Float32Array(0);\n\n  function initBuffer(): void {\n    _bytesWritten = 0;\n    buffer = new Float32Array(0);\n  }\n\n  function isBufferFull(): boolean {\n    return _bytesWritten === bufferSize;\n  }\n\n  function flush(): void {\n    initBuffer();\n  }\n\n  return function (pcmData: Float32Array): AggregateData {\n    if (isBufferFull()) {\n      flush();\n    }\n\n    const newBuffer = new Float32Array(buffer.length + pcmData.length);\n    newBuffer.set(buffer, 0);\n    newBuffer.set(pcmData, buffer.length);\n    buffer = newBuffer;\n    _bytesWritten += pcmData.length;\n\n    return {\n      isBufferFull: isBufferFull(),\n      buffer,\n      bufferSize,\n    };\n  };\n}\n", "import {descendingOverThresholds} from './utils';\nimport type {Peaks, ValidPeaks, PeaksAndThreshold, BpmCandidates, Interval, Tempo, Threshold, Group} from './types';\nimport * as consts from './consts';\n\n/**\n * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol\n * @param {Float32Array} data Buffer channel data\n * @param {number} threshold Threshold for qualifying as a peak\n * @param {number} offset Position where we start to loop\n * @param {number} skipForwardIndexes Numbers of index to skip when a peak is detected\n * @return {PeaksAndThreshold} Peaks found that are greater than the threshold\n */\nexport function findPeaksAtThreshold(data: Float32Array, threshold: Threshold, offset = 0, skipForwardIndexes = consts.skipForwardIndexes): PeaksAndThreshold {\n  const peaks: Peaks = [];\n\n  const {length} = data;\n\n  /**\n   * Identify peaks that are greater than the threshold, adding them to the collection\n   */\n  for (let i = offset; i < length; i += 1) {\n    if (data[i] > threshold) {\n      peaks.push(i);\n\n      /**\n       * Skip forward ~0.25s to pass this peak\n       */\n      i += skipForwardIndexes;\n    }\n  }\n\n  return {\n    peaks,\n    threshold,\n  };\n}\n\n/**\n * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm\n * @param {Float32Array} channelData Channel data\n * @returns {Promise<PeaksAndThreshold>} Suffisent amount of peaks in order to continue further the process\n */\nexport async function findPeaks(channelData: Float32Array): Promise<PeaksAndThreshold> {\n  let validPeaks: Peaks = [];\n  let validThreshold = 0;\n\n  await descendingOverThresholds(async threshold => {\n    const {peaks} = findPeaksAtThreshold(channelData, threshold);\n\n    /**\n     * Loop over peaks\n     */\n    if (peaks.length < consts.minPeaks) {\n      return false;\n    }\n\n    validPeaks = peaks;\n    validThreshold = threshold;\n\n    return true;\n  });\n\n  return {\n    peaks: validPeaks,\n    threshold: validThreshold,\n  };\n}\n\n// Type MaxInterval = {\n//   position: number;\n//   volume: number;\n// };\n\n// export function getPeaks(data: Float32Array[], sampleRate: number): MaxInterval[] {\n//   // What we're going to do here, is to divide up our audio into parts.\n\n//   // We will then identify, for each part, what the loudest sample is in that\n//   // part.\n\n//   // It's implied that that sample would represent the most likely 'beat'\n//   // within that part.\n\n//   // Each part is 0.5 seconds long - or 22,050 samples.\n\n//   // This will give us 60 'beats' - we will only take the loudest half of\n//   // those.\n\n//   // This will allow us to ignore breaks, and allow us to address tracks with\n//   // a BPM below 120.\n\n//   // const partSize = 22050;\n//   const partSize = sampleRate / 2;\n//   console.log('partSize, 22050', partSize, 'sampleRate', sampleRate);\n//   const parts = data[0].length / partSize;\n//   let peaks: MaxInterval[] = [];\n\n//   for (let i = 0; i < parts; i++) {\n//     let max: number | MaxInterval = 0;\n//     for (let j = i * partSize; j < (i + 1) * partSize; j++) {\n//       const volume = Math.max(Math.abs(data[0][j]), Math.abs(data[1][j]));\n//       if (typeof max === 'number' || (volume > max.volume)) {\n//         max = {\n//           position: j,\n//           volume,\n//         };\n//       }\n//     }\n\n//     if (typeof max !== 'number') {\n//       peaks.push(max);\n//     }\n//   }\n\n//   // We then sort the peaks according to volume...\n\n//   peaks.sort((a, b) => b.volume - a.volume);\n\n//   // ...take the loundest half of those...\n\n//   peaks = peaks.splice(0, peaks.length * 0.5);\n\n//   // ...and re-sort it back based on position.\n\n//   peaks.sort((a, b) => a.position - b.position);\n\n//   return peaks;\n// }\n\n// export function getIntervals(peaks: MaxInterval[]): Group[] {\n//   // What we now do is get all of our peaks, and then measure the distance to\n//   // other peaks, to create intervals.  Then based on the distance between\n//   // those peaks (the distance of the intervals) we can calculate the BPM of\n//   // that particular interval.\n\n//   // The interval that is seen the most should have the BPM that corresponds\n//   // to the track itself.\n\n//   const groups: Group[] = [];\n\n//   for (let index = 0; index < peaks.length; index++) {\n//     const peak = peaks[index];\n//     for (let i = 1; (index + i) < peaks.length && i < 10; i++) {\n//       const group: Group = {\n//         tempo: (60 * 44100) / (peaks[index + i].position - peak.position),\n//         count: 1,\n//       };\n\n//       while (group.tempo < 90) {\n//         group.tempo *= 2;\n//       }\n\n//       while (group.tempo > 180) {\n//         group.tempo /= 2;\n//       }\n\n//       group.tempo = Math.round(group.tempo);\n\n//       if (!(groups.some(interval => (interval.tempo === group.tempo ? interval.count++ : 0)))) {\n//         groups.push(group);\n//       }\n//     }\n//   }\n\n//   return groups;\n// }\n\n// export function getTop(groups: Group[]): Group[] {\n//   return groups.sort(function(intA, intB) {\n//     return intB.count - intA.count;\n//   }).splice(0, 5);\n// };\n\n// export function getNewAlgorithmBPM(audioBuffer: AudioBuffer) {\n//   const peaks = getPeaks([audioBuffer.getChannelData(0), audioBuffer.getChannelData(1)], audioBuffer.sampleRate);\n//   console.log('peaks', peaks);\n//   const groups = getIntervals(peaks);\n//   console.log('groups', groups);\n//   const tops = getTop(groups);\n//   return tops;\n// }\n\nexport function getBiquadFilters(context: AudioContext | OfflineAudioContext) {\n  const lowpass = context.createBiquadFilter();\n  lowpass.type = 'lowpass';\n  lowpass.frequency.value = consts.offlineLowPassFrequencyValue;\n  lowpass.Q.value = consts.offlineLowPassQualityValue;\n\n  const highpass = context.createBiquadFilter();\n  highpass.type = 'highpass';\n  highpass.frequency.value = consts.offlineHighPassFrequencyValue;\n  highpass.Q.value = consts.offlineHighPassQualityValue;\n\n  return {\n    lowpass,\n    highpass,\n  };\n}\n\n/**\n * Apply to the source a biquad lowpass filter\n * @param {AudioBuffer} buffer Audio buffer\n * @returns {AudioBufferSourceNode}\n */\nexport async function getOfflineLowPassSource(buffer: AudioBuffer): Promise<AudioBuffer> {\n  const {length, numberOfChannels, sampleRate} = buffer;\n  const context = new OfflineAudioContext(numberOfChannels, length, sampleRate);\n\n  /**\n   * Create buffer source\n   */\n  const source = context.createBufferSource();\n  source.buffer = buffer;\n\n  const {lowpass, highpass} = getBiquadFilters(context);\n\n  /**\n   * Pipe the song into the filter, and the filter into the offline context\n   */\n  source.connect(lowpass);\n  source.connect(highpass);\n  lowpass.connect(highpass);\n  highpass.connect(context.destination);\n\n  source.start(0);\n\n  const audioBuffer = await context.startRendering();\n\n  return audioBuffer;\n}\n\n/**\n * Return the computed bpm from data\n * @param {Record<string, number[]>} data Contain valid peaks\n * @param {number} audioSampleRate Audio sample rate\n */\nexport async function computeBpm(data: ValidPeaks, audioSampleRate: number, minPeaks = consts.minPeaks): Promise<BpmCandidates> {\n  /**\n   * Flag to fix Object.keys looping\n   */\n  let hasPeaks = false;\n  let foundThreshold = consts.minValidThreshold;\n\n  await descendingOverThresholds(async (threshold: Threshold) => {\n    if (hasPeaks) {\n      return true;\n    }\n\n    if (data[threshold].length > minPeaks) {\n      hasPeaks = true;\n      foundThreshold = threshold;\n    }\n\n    return false;\n  });\n\n  if (hasPeaks && foundThreshold) {\n    const intervals = identifyIntervals(data[foundThreshold]);\n    const tempos = groupByTempo(audioSampleRate, intervals);\n    const candidates = getTopCandidates(tempos);\n\n    const bpmCandidates: BpmCandidates = {\n      bpm: candidates,\n      threshold: foundThreshold,\n    };\n\n    return bpmCandidates;\n  }\n\n  return {\n    bpm: [],\n    threshold: foundThreshold,\n  };\n}\n\n/**\n * Sort results by count and return top candidate\n * @param {Tempo[]} candidates (BPMs) with count\n * @param {number} length Amount of returned candidates (default: 5)\n * @return {Tempo[]} Returns the 5 top candidates with highest counts\n */\nexport function getTopCandidates(candidates: Tempo[], length = 5): Tempo[] {\n  return candidates.sort((a, b) => (b.count - a.count)).splice(0, length);\n}\n\n/**\n * Gets the top candidate from the array\n * @param {Tempo[]} candidates - (BPMs) with counts.\n * @returns {number} - Returns the top candidate with the highest count.\n */\nexport function getTopCandidate(candidates: Tempo[]): number {\n  if (candidates.length === 0) {\n    throw new Error('Could not find enough samples for a reliable detection.');\n  }\n\n  const [first] = candidates.sort((a, b) => (b.count - a.count));\n\n  return first.tempo;\n}\n\n/**\n * Identify intervals between bass peaks\n * @param {array} peaks Array of qualified bass peaks\n * @return {array} Return a collection of intervals between peaks\n */\nexport function identifyIntervals(peaks: Peaks): Interval[] {\n  const intervals: Interval[] = [];\n\n  for (let n = 0; n < peaks.length; n++) {\n    for (let i = 0; i < 10; i++) {\n      const peak = peaks[n];\n      const peakIndex = n + i;\n      const interval = peaks[peakIndex] - peak;\n\n      /**\n       * Try and find a matching interval and increase it's count\n       */\n      const foundInterval = intervals.some((intervalCount: Interval) => {\n        if (intervalCount.interval === interval) {\n          intervalCount.count += 1;\n          return intervalCount.count;\n        }\n\n        return false;\n      });\n\n      /**\n       * Add the interval to the collection if it's unique\n       */\n      if (!foundInterval) {\n        const item: Interval = {\n          interval,\n          count: 1,\n        };\n        intervals.push(item);\n      }\n    }\n  }\n\n  return intervals;\n}\n\n/**\n * Figure out best possible tempo candidates\n * @param  {number} audioSampleRate Audio sample rate\n * @param  {Interval[]} intervalCounts List of identified intervals\n * @return {Tempo[]} Intervals grouped with similar values\n */\nexport function groupByTempo(audioSampleRate: number, intervalCounts: Interval[]): Tempo[] {\n  const tempoCounts: Tempo[] = [];\n\n  for (const intervalCount of intervalCounts) {\n    /**\n     * Skip if interval is equal 0\n     */\n    if (intervalCount.interval === 0) {\n      continue;\n    }\n\n    intervalCount.interval = Math.abs(intervalCount.interval);\n\n    /**\n     * Convert an interval to tempo\n     */\n    let theoreticalTempo = (60 / (intervalCount.interval / audioSampleRate));\n\n    /**\n     * Adjust the tempo to fit within the 90-180 BPM range\n     */\n    while (theoreticalTempo < 90) {\n      theoreticalTempo *= 2;\n    }\n\n    while (theoreticalTempo > 180) {\n      theoreticalTempo /= 2;\n    }\n\n    /**\n     * Round to legible integer\n     */\n    theoreticalTempo = Math.round(theoreticalTempo);\n\n    /**\n     * See if another interval resolved to the same tempo\n     */\n    const foundTempo: boolean = tempoCounts.some((tempoCount: Tempo) => {\n      if (tempoCount.tempo === theoreticalTempo) {\n        tempoCount.count += intervalCount.count;\n        return tempoCount.count;\n      }\n\n      return false;\n    });\n\n    /**\n     * Add a unique tempo to the collection\n     */\n    if (!foundTempo) {\n      const tempo: Tempo = {\n        tempo: theoreticalTempo,\n        count: intervalCount.count,\n        confidence: 0,\n      };\n\n      tempoCounts.push(tempo);\n    }\n  }\n\n  return tempoCounts;\n}\n\n/**\n * Function to detect the BPM from an AudioBuffer (which can be a whole file)\n * It is the fastest way to detect the BPM\n * @param {AudioBuffer} buffer AudioBuffer\n * @returns {Promise<Tempo[]>} Returns the 5 bests candidates\n */\nexport async function analyzeFullBuffer(buffer: AudioBuffer): Promise<Tempo[]> {\n  const sourceBuffer = await getOfflineLowPassSource(buffer);\n\n  /**\n   * Pipe the source through the program\n   */\n  // const newAlgorithm = getNewAlgorithmBPM(sourceBuffer);\n  // console.log('newAlgorithm', newAlgorithm);\n\n  const channelData = sourceBuffer.getChannelData(0);\n\n  const {peaks} = await findPeaks(channelData);\n  const intervals = identifyIntervals(peaks);\n  const tempos = groupByTempo(buffer.sampleRate, intervals);\n  const topCandidates = getTopCandidates(tempos, channelData.length);\n\n  return topCandidates;\n}\n", "import {findPeaksAtThreshold, computeBpm} from './analyzer';\nimport type {RealTimeBpmAnalyzerOptions, RealTimeBpmAnalyzerParameters, ValidPeaks, NextIndexPeaks, BpmCandidates, Threshold, BpmEventData} from './types';\nimport {generateValidPeaksModel, generateNextIndexPeaksModel, descendingOverThresholds} from './utils';\nimport * as consts from './consts';\n\n/**\n * Initial value of key parameters of the analyzer\n */\nconst initialValue = {\n  minValidThreshold: () => consts.minValidThreshold,\n  timeoutStabilization: () => 0,\n  validPeaks: () => generateValidPeaksModel(),\n  nextIndexPeaks: () => generateNextIndexPeaksModel(),\n  skipIndexes: () => 1,\n};\n\n/**\n * @class RealTimeBpmAnalyzer\n **/\nexport class RealTimeBpmAnalyzer {\n  /**\n   * Default configuration\n   */\n  options: RealTimeBpmAnalyzerOptions = {\n    continuousAnalysis: false,\n    stabilizationTime: 20000,\n    muteTimeInIndexes: 10000,\n  };\n\n  /**\n   * Minimum valid threshold, below this level result would be irrelevant.\n   */\n  minValidThreshold: Threshold = initialValue.minValidThreshold();\n  /**\n   * Schedule timeout triggered when the stabilizationTime is reached\n   */\n  timeoutStabilization: number = initialValue.timeoutStabilization();\n  /**\n   * Contain all valid peaks\n   */\n  validPeaks: ValidPeaks = initialValue.validPeaks();\n  /**\n   * Next index (+10000 ...) to take care about peaks\n   */\n  nextIndexPeaks: NextIndexPeaks = initialValue.nextIndexPeaks();\n  /**\n   * Number / Position of chunks\n   */\n  skipIndexes: number = initialValue.skipIndexes();\n\n  /**\n   * @constructor\n   * @param {object} config Configuration\n   * @param {boolean} config.continuousAnalysis Flag indicating if we need to analyze continuously, typically used for streams\n   * @param {number} config.stabilizationTime The algorithm needs aproximatly 10s to compute accurate results\n   * @param {number} config.muteTimeInIndexes Arbitrary time to mute the analysis to improve the bpm detection by jumping data right after a peak\n   */\n  constructor(config: RealTimeBpmAnalyzerParameters = {}) {\n    /**\n     * Overriding default configuration\n     */\n    Object.assign(this.options, config);\n  }\n\n  /**\n   * Method to apply a configuration on the fly\n   * @param {RealtimeBpmAnalyzerAsyncOptions} key Key of the configuration in this.options\n   * @param {unknown} value The value you need to set\n   * @returns {void}\n   */\n  setAsyncConfiguration(parameters: RealTimeBpmAnalyzerParameters): void {\n    Object.assign(this.options, parameters);\n  }\n\n  /**\n   * Reset BPM computation properties to get a fresh start\n   * @returns {void}\n   */\n  reset(): void {\n    this.minValidThreshold = initialValue.minValidThreshold();\n    this.timeoutStabilization = initialValue.timeoutStabilization();\n    this.validPeaks = initialValue.validPeaks();\n    this.nextIndexPeaks = initialValue.nextIndexPeaks();\n    this.skipIndexes = initialValue.skipIndexes();\n  }\n\n  /**\n   * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas\n   * @param {Threshold} minThreshold Value between 0.9 and 0.3\n   * @returns {void}\n   */\n  async clearValidPeaks(minThreshold: Threshold): Promise<void> {\n    console.log(`[clearValidPeaks] function: under ${minThreshold}, this.minValidThreshold has been setted to that threshold.`);\n    this.minValidThreshold = Number.parseFloat(minThreshold.toFixed(2));\n\n    await descendingOverThresholds(async threshold => {\n      if (threshold < minThreshold) {\n        delete this.validPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        delete this.nextIndexPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime\n   * @param {Float32Array} channelData Channel data\n   * @param {number} audioSampleRate Audio sample rate\n   * @param {number} bufferSize Buffer size\n   * @param {(data: any) => void} postMessage Function to post a message to the processor node\n   * @returns {Promise<void>}\n   */\n  async analyzeChunck(channelData: Float32Array, audioSampleRate: number, bufferSize: number, postMessage: (data: BpmEventData) => void): Promise<void> {\n    /**\n     * Compute the maximum index with all previous chunks\n     */\n    const currentMaxIndex = bufferSize * this.skipIndexes;\n\n    /**\n     * Compute the minimum index with all previous chunks\n     */\n    const currentMinIndex = currentMaxIndex - bufferSize;\n\n    /**\n     * Mutate nextIndexPeaks and validPeaks if possible\n     */\n    await this.findPeaks(channelData, bufferSize, currentMinIndex, currentMaxIndex);\n\n    /**\n     * Increment chunk\n     */\n    this.skipIndexes++;\n\n    const result: BpmCandidates = await computeBpm(this.validPeaks, audioSampleRate);\n    const {threshold} = result;\n    postMessage({message: 'BPM', result});\n\n    if (this.minValidThreshold < threshold) {\n      postMessage({message: 'BPM_STABLE', result});\n      await this.clearValidPeaks(threshold);\n    }\n\n    /**\n     * After x milliseconds, we reinit the analyzer\n     */\n    if (this.options.continuousAnalysis) {\n      clearTimeout(this.timeoutStabilization);\n      this.timeoutStabilization = window.setTimeout(() => {\n        console.log('[timeoutStabilization] setTimeout: Fired !');\n        this.reset();\n      }, this.options.stabilizationTime);\n    }\n  }\n\n  /**\n   * Find the best threshold with enought peaks\n   * @param {Float32Array} channelData Channel data\n   * @param {number} bufferSize Buffer size\n   * @param {number} currentMinIndex Current minimum index\n   * @param {number} currentMaxIndex Current maximum index\n   * @returns {void}\n   */\n  async findPeaks(channelData: Float32Array, bufferSize: number, currentMinIndex: number, currentMaxIndex: number): Promise<void> {\n    await descendingOverThresholds(async threshold => {\n      if (this.nextIndexPeaks[threshold] >= currentMaxIndex) {\n        return false;\n      }\n\n      /**\n       * Get the next index in the next chunk\n       */\n      const offsetForNextPeak = this.nextIndexPeaks[threshold] % bufferSize; // 0 - 4095\n\n      const {peaks, threshold: atThreshold} = findPeaksAtThreshold(channelData, threshold, offsetForNextPeak);\n\n      /**\n       * Loop over peaks\n       */\n      if (peaks.length === 0) {\n        return false;\n      }\n\n      for (const relativeChunkPeak of peaks) {\n        /**\n         * Add current Index + muteTimeInIndexes (10000/44100=0.22s)\n         */\n        this.nextIndexPeaks[atThreshold] = currentMinIndex + relativeChunkPeak + this.options.muteTimeInIndexes;\n\n        /**\n         * Store valid relativeChunkPeak Indexes\n         */\n        this.validPeaks[atThreshold].push(currentMinIndex + relativeChunkPeak);\n      }\n\n      return false;\n    }, this.minValidThreshold);\n  }\n}\n", "import {realtimeBpmProcessorName} from './consts';\n\nexport * from './realtime-bpm-analyzer';\nexport {analyzeFullBuffer, getBiquadFilters} from './analyzer';\nexport * from './types';\n\n/**\n * Create the RealTimeBpmProcessor needed to run the realtime strategy\n * ENsure that the biquad lowpass filter is done before using this library\n * @param {AudioContext} audioContext AudioContext instance\n * @returns {Promise<AudioWorkletNode>}\n * @public\n */\nexport async function createRealTimeBpmProcessor(audioContext: AudioContext, realtimeBpmProcessorPath = `/${realtimeBpmProcessorName}.js`): Promise<AudioWorkletNode> {\n  const processorNode = await setupAudioWorkletNode(audioContext, realtimeBpmProcessorPath, realtimeBpmProcessorName);\n\n  await audioContext.resume();\n\n  return processorNode;\n}\n\n/**\n * Creates AudioWorkletNode for the Processor\n * @param {AudioContext} audioContext AudioContext instance\n * @param {string} processorName Name of the audio processor, without the extension\n * @return {Promise<AudioWorkletNode>} Recording node related components for the app.\n * @private\n */\nasync function setupAudioWorkletNode(audioContext: AudioContext, pathToProcessor: string, processorName: string): Promise<AudioWorkletNode> {\n  try {\n    await audioContext.audioWorklet.addModule(pathToProcessor);\n\n    const audioWorkletNode = new AudioWorkletNode(audioContext, processorName);\n\n    return audioWorkletNode;\n  } catch (error: unknown) {\n    console.error('setupAudioWorkletNode ERROR', error);\n    throw error;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;AAAO,IAAM,2BAA2B;AACjC,IAAM,iBAAiB;AACvB,IAAM,oBAAoB;AAC1B,IAAM,WAAW;AACjB,IAAM,gBAAgB;AACtB,IAAM,qBAAqB;AAC3B,IAAM,+BAA+B;AACrC,IAAM,6BAA6B;AACnC,IAAM,gCAAgC;AACtC,IAAM,8BAA8B;;;ACE3C,SAAsB,yBAAyB,IAA6K;AAAA,6CAA7K,aAAkCA,qBAA2B,mBAAmBC,kBAAwB,gBAAgBC,iBAAuB,eAA8B;AAC1N,QAAI,YAAYD;AAEhB,OAAG;AACD,mBAAaC;AACb,YAAM,aAAa,MAAM,YAAY,SAAS;AAC9C,UAAI,YAAY;AACd;AAAA,MACF;AAAA,IACF,SAAS,YAAYF;AAAA,EACvB;AAAA;AASO,SAAS,wBAAwBA,qBAA2B,mBAAmBC,kBAAwB,gBAAgBC,iBAAuB,eAA2B;AAC9K,QAAM,SAAgC,CAAC;AACvC,MAAI,YAAYD;AAEhB,KAAG;AACD,iBAAaC;AACb,WAAO,UAAU,SAAS,KAAK,CAAC;AAAA,EAClC,SAAS,YAAYF;AAErB,SAAO;AACT;AAMO,SAAS,4BAA4BA,qBAA2B,mBAAmBC,kBAAwB,gBAAgBC,iBAAuB,eAA+B;AACtL,QAAM,SAAiC,CAAC;AACxC,MAAI,YAAYD;AAEhB,KAAG;AACD,iBAAaC;AACb,WAAO,UAAU,SAAS,KAAK;AAAA,EACjC,SAAS,YAAYF;AAErB,SAAO;AACT;;;AC5CO,SAAS,qBAAqB,MAAoB,WAAsB,SAAS,GAAGG,sBAA4B,oBAAuC;AAC5J,QAAM,QAAe,CAAC;AAEtB,QAAM,EAAC,OAAM,IAAI;AAKjB,WAAS,IAAI,QAAQ,IAAI,QAAQ,KAAK,GAAG;AACvC,QAAI,KAAK,KAAK,WAAW;AACvB,YAAM,KAAK,CAAC;AAKZ,WAAKA;AAAA,IACP;AAAA,EACF;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAOA,SAAsB,UAAU,aAAuD;AAAA;AACrF,QAAI,aAAoB,CAAC;AACzB,QAAI,iBAAiB;AAErB,UAAM,yBAAyB,CAAM,cAAa;AAChD,YAAM,EAAC,MAAK,IAAI,qBAAqB,aAAa,SAAS;AAK3D,UAAI,MAAM,SAAgB,UAAU;AAClC,eAAO;AAAA,MACT;AAEA,mBAAa;AACb,uBAAiB;AAEjB,aAAO;AAAA,IACT,EAAC;AAED,WAAO;AAAA,MACL,OAAO;AAAA,MACP,WAAW;AAAA,IACb;AAAA,EACF;AAAA;AAmHO,SAAS,iBAAiB,SAA6C;AAC5E,QAAM,UAAU,QAAQ,mBAAmB;AAC3C,UAAQ,OAAO;AACf,UAAQ,UAAU,QAAe;AACjC,UAAQ,EAAE,QAAe;AAEzB,QAAM,WAAW,QAAQ,mBAAmB;AAC5C,WAAS,OAAO;AAChB,WAAS,UAAU,QAAe;AAClC,WAAS,EAAE,QAAe;AAE1B,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAOA,SAAsB,wBAAwB,QAA2C;AAAA;AACvF,UAAM,EAAC,QAAQ,kBAAkB,WAAU,IAAI;AAC/C,UAAM,UAAU,IAAI,oBAAoB,kBAAkB,QAAQ,UAAU;AAK5E,UAAM,SAAS,QAAQ,mBAAmB;AAC1C,WAAO,SAAS;AAEhB,UAAM,EAAC,SAAS,SAAQ,IAAI,iBAAiB,OAAO;AAKpD,WAAO,QAAQ,OAAO;AACtB,WAAO,QAAQ,QAAQ;AACvB,YAAQ,QAAQ,QAAQ;AACxB,aAAS,QAAQ,QAAQ,WAAW;AAEpC,WAAO,MAAM,CAAC;AAEd,UAAM,cAAc,MAAM,QAAQ,eAAe;AAEjD,WAAO;AAAA,EACT;AAAA;AAOA,SAAsB,WAAW,IAAkB,IAA6E;AAAA,6CAA/F,MAAkB,iBAAyBC,YAAkB,UAAkC;AAI9H,QAAI,WAAW;AACf,QAAI,iBAAwB;AAE5B,UAAM,yBAAyB,CAAO,cAAyB;AAC7D,UAAI,UAAU;AACZ,eAAO;AAAA,MACT;AAEA,UAAI,KAAK,WAAW,SAASA,WAAU;AACrC,mBAAW;AACX,yBAAiB;AAAA,MACnB;AAEA,aAAO;AAAA,IACT,EAAC;AAED,QAAI,YAAY,gBAAgB;AAC9B,YAAM,YAAY,kBAAkB,KAAK,eAAe;AACxD,YAAM,SAAS,aAAa,iBAAiB,SAAS;AACtD,YAAM,aAAa,iBAAiB,MAAM;AAE1C,YAAM,gBAA+B;AAAA,QACnC,KAAK;AAAA,QACL,WAAW;AAAA,MACb;AAEA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,MACL,KAAK,CAAC;AAAA,MACN,WAAW;AAAA,IACb;AAAA,EACF;AAAA;AAQO,SAAS,iBAAiB,YAAqB,SAAS,GAAY;AACzE,SAAO,WAAW,KAAK,CAAC,GAAG,MAAO,EAAE,QAAQ,EAAE,KAAM,EAAE,OAAO,GAAG,MAAM;AACxE;AAsBO,SAAS,kBAAkB,OAA0B;AAC1D,QAAM,YAAwB,CAAC;AAE/B,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAM,OAAO,MAAM;AACnB,YAAM,YAAY,IAAI;AACtB,YAAM,WAAW,MAAM,aAAa;AAKpC,YAAM,gBAAgB,UAAU,KAAK,CAAC,kBAA4B;AAChE,YAAI,cAAc,aAAa,UAAU;AACvC,wBAAc,SAAS;AACvB,iBAAO,cAAc;AAAA,QACvB;AAEA,eAAO;AAAA,MACT,CAAC;AAKD,UAAI,CAAC,eAAe;AAClB,cAAM,OAAiB;AAAA,UACrB;AAAA,UACA,OAAO;AAAA,QACT;AACA,kBAAU,KAAK,IAAI;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAQO,SAAS,aAAa,iBAAyB,gBAAqC;AACzF,QAAM,cAAuB,CAAC;AAE9B,aAAW,iBAAiB,gBAAgB;AAI1C,QAAI,cAAc,aAAa,GAAG;AAChC;AAAA,IACF;AAEA,kBAAc,WAAW,KAAK,IAAI,cAAc,QAAQ;AAKxD,QAAI,mBAAoB,MAAM,cAAc,WAAW;AAKvD,WAAO,mBAAmB,IAAI;AAC5B,0BAAoB;AAAA,IACtB;AAEA,WAAO,mBAAmB,KAAK;AAC7B,0BAAoB;AAAA,IACtB;AAKA,uBAAmB,KAAK,MAAM,gBAAgB;AAK9C,UAAM,aAAsB,YAAY,KAAK,CAAC,eAAsB;AAClE,UAAI,WAAW,UAAU,kBAAkB;AACzC,mBAAW,SAAS,cAAc;AAClC,eAAO,WAAW;AAAA,MACpB;AAEA,aAAO;AAAA,IACT,CAAC;AAKD,QAAI,CAAC,YAAY;AACf,YAAM,QAAe;AAAA,QACnB,OAAO;AAAA,QACP,OAAO,cAAc;AAAA,QACrB,YAAY;AAAA,MACd;AAEA,kBAAY,KAAK,KAAK;AAAA,IACxB;AAAA,EACF;AAEA,SAAO;AACT;AAQA,SAAsB,kBAAkB,QAAuC;AAAA;AAC7E,UAAM,eAAe,MAAM,wBAAwB,MAAM;AAQzD,UAAM,cAAc,aAAa,eAAe,CAAC;AAEjD,UAAM,EAAC,MAAK,IAAI,MAAM,UAAU,WAAW;AAC3C,UAAM,YAAY,kBAAkB,KAAK;AACzC,UAAM,SAAS,aAAa,OAAO,YAAY,SAAS;AACxD,UAAM,gBAAgB,iBAAiB,QAAQ,YAAY,MAAM;AAEjE,WAAO;AAAA,EACT;AAAA;;;ACzaA,IAAM,eAAe;AAAA,EACnB,mBAAmB,MAAa;AAAA,EAChC,sBAAsB,MAAM;AAAA,EAC5B,YAAY,MAAM,wBAAwB;AAAA,EAC1C,gBAAgB,MAAM,4BAA4B;AAAA,EAClD,aAAa,MAAM;AACrB;AAKO,IAAM,sBAAN,MAA0B;AAAA,EAsC/B,YAAY,SAAwC,CAAC,GAAG;AAlCxD,mBAAsC;AAAA,MACpC,oBAAoB;AAAA,MACpB,mBAAmB;AAAA,MACnB,mBAAmB;AAAA,IACrB;AAKA,6BAA+B,aAAa,kBAAkB;AAI9D,gCAA+B,aAAa,qBAAqB;AAIjE,sBAAyB,aAAa,WAAW;AAIjD,0BAAiC,aAAa,eAAe;AAI7D,uBAAsB,aAAa,YAAY;AAa7C,WAAO,OAAO,KAAK,SAAS,MAAM;AAAA,EACpC;AAAA,EAQA,sBAAsB,YAAiD;AACrE,WAAO,OAAO,KAAK,SAAS,UAAU;AAAA,EACxC;AAAA,EAMA,QAAc;AACZ,SAAK,oBAAoB,aAAa,kBAAkB;AACxD,SAAK,uBAAuB,aAAa,qBAAqB;AAC9D,SAAK,aAAa,aAAa,WAAW;AAC1C,SAAK,iBAAiB,aAAa,eAAe;AAClD,SAAK,cAAc,aAAa,YAAY;AAAA,EAC9C;AAAA,EAOM,gBAAgB,cAAwC;AAAA;AAC5D,cAAQ,IAAI,qCAAqC,yEAAyE;AAC1H,WAAK,oBAAoB,OAAO,WAAW,aAAa,QAAQ,CAAC,CAAC;AAElE,YAAM,yBAAyB,CAAM,cAAa;AAChD,YAAI,YAAY,cAAc;AAC5B,iBAAO,KAAK,WAAW;AACvB,iBAAO,KAAK,eAAe;AAAA,QAC7B;AAEA,eAAO;AAAA,MACT,EAAC;AAAA,IACH;AAAA;AAAA,EAUM,cAAc,aAA2B,iBAAyB,YAAoB,aAA0D;AAAA;AAIpJ,YAAM,kBAAkB,aAAa,KAAK;AAK1C,YAAM,kBAAkB,kBAAkB;AAK1C,YAAM,KAAK,UAAU,aAAa,YAAY,iBAAiB,eAAe;AAK9E,WAAK;AAEL,YAAM,SAAwB,MAAM,WAAW,KAAK,YAAY,eAAe;AAC/E,YAAM,EAAC,UAAS,IAAI;AACpB,kBAAY,EAAC,SAAS,OAAO,OAAM,CAAC;AAEpC,UAAI,KAAK,oBAAoB,WAAW;AACtC,oBAAY,EAAC,SAAS,cAAc,OAAM,CAAC;AAC3C,cAAM,KAAK,gBAAgB,SAAS;AAAA,MACtC;AAKA,UAAI,KAAK,QAAQ,oBAAoB;AACnC,qBAAa,KAAK,oBAAoB;AACtC,aAAK,uBAAuB,OAAO,WAAW,MAAM;AAClD,kBAAQ,IAAI,4CAA4C;AACxD,eAAK,MAAM;AAAA,QACb,GAAG,KAAK,QAAQ,iBAAiB;AAAA,MACnC;AAAA,IACF;AAAA;AAAA,EAUM,UAAU,aAA2B,YAAoB,iBAAyB,iBAAwC;AAAA;AAC9H,YAAM,yBAAyB,CAAM,cAAa;AAChD,YAAI,KAAK,eAAe,cAAc,iBAAiB;AACrD,iBAAO;AAAA,QACT;AAKA,cAAM,oBAAoB,KAAK,eAAe,aAAa;AAE3D,cAAM,EAAC,OAAO,WAAW,YAAW,IAAI,qBAAqB,aAAa,WAAW,iBAAiB;AAKtG,YAAI,MAAM,WAAW,GAAG;AACtB,iBAAO;AAAA,QACT;AAEA,mBAAW,qBAAqB,OAAO;AAIrC,eAAK,eAAe,eAAe,kBAAkB,oBAAoB,KAAK,QAAQ;AAKtF,eAAK,WAAW,aAAa,KAAK,kBAAkB,iBAAiB;AAAA,QACvE;AAEA,eAAO;AAAA,MACT,IAAG,KAAK,iBAAiB;AAAA,IAC3B;AAAA;AACF;;;ACzLA,SAAsB,2BAA2B,IAAqH;AAAA,6CAArH,cAA4B,2BAA2B,IAAI,+BAA0D;AACpK,UAAM,gBAAgB,MAAM,sBAAsB,cAAc,0BAA0B,wBAAwB;AAElH,UAAM,aAAa,OAAO;AAE1B,WAAO;AAAA,EACT;AAAA;AASA,SAAe,sBAAsB,cAA4B,iBAAyB,eAAkD;AAAA;AAC1I,QAAI;AACF,YAAM,aAAa,aAAa,UAAU,eAAe;AAEzD,YAAM,mBAAmB,IAAI,iBAAiB,cAAc,aAAa;AAEzE,aAAO;AAAA,IACT,SAAS,OAAP;AACA,cAAQ,MAAM,+BAA+B,KAAK;AAClD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;",
  "names": ["minValidThreshold", "startThreshold", "thresholdStep", "skipForwardIndexes", "minPeaks"]
}
