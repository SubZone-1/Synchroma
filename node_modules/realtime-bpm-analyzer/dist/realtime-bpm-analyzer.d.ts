import type { RealTimeBpmAnalyzerOptions, RealTimeBpmAnalyzerParameters, ValidPeaks, NextIndexPeaks, Threshold, BpmEventData } from './types';
/**
 * @class RealTimeBpmAnalyzer
 **/
export declare class RealTimeBpmAnalyzer {
    /**
     * Default configuration
     */
    options: RealTimeBpmAnalyzerOptions;
    /**
     * Minimum valid threshold, below this level result would be irrelevant.
     */
    minValidThreshold: Threshold;
    /**
     * Schedule timeout triggered when the stabilizationTime is reached
     */
    timeoutStabilization: number;
    /**
     * Contain all valid peaks
     */
    validPeaks: ValidPeaks;
    /**
     * Next index (+10000 ...) to take care about peaks
     */
    nextIndexPeaks: NextIndexPeaks;
    /**
     * Number / Position of chunks
     */
    skipIndexes: number;
    /**
     * @constructor
     * @param {object} config Configuration
     * @param {boolean} config.continuousAnalysis Flag indicating if we need to analyze continuously, typically used for streams
     * @param {number} config.computeBpmDelay Arbitrary delay to compute the BPM for the first time
     * @param {number} config.stabilizationTime Arbitrary time where we consider that a BPM is computable
     * @param {number} config.muteTimeInIndexes Arbitrary time to mute the analysis to improve the bpm detection
     */
    constructor(config?: RealTimeBpmAnalyzerParameters);
    /**
     * Method to apply a configuration on the fly
     * @param {RealtimeBpmAnalyzerAsyncOptions} key Key of the configuration in this.options
     * @param {unknown} value The value you need to set
     * @returns {void}
     */
    setAsyncConfiguration(parameters: RealTimeBpmAnalyzerParameters): void;
    /**
     * Reset BPM computation properties to get a fresh start
     * @returns {void}
     */
    reset(): void;
    /**
     * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas
     * @param {Threshold} minThreshold Value between 0.9 and 0.3
     * @returns {void}
     */
    clearValidPeaks(minThreshold: Threshold): Promise<void>;
    /**
     * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime
     * @param {Float32Array} channelData Channel data
     * @param {number} audioSampleRate Audio sample rate
     * @param {number} bufferSize Buffer size
     * @param {(data: any) => void} postMessage Function to post a message to the processor node
     * @returns {Promise<void>}
     */
    analyzeChunck(channelData: Float32Array, audioSampleRate: number, bufferSize: number, postMessage: (data: BpmEventData) => void): Promise<void>;
    /**
     * Find the best threshold with enought peaks
     * @param {Float32Array} channelData Channel data
     * @param {number} bufferSize Buffer size
     * @param {number} currentMinIndex Current minimum index
     * @param {number} currentMaxIndex Current maximum index
     * @returns {void}
     */
    findPeaks(channelData: Float32Array, bufferSize: number, currentMinIndex: number, currentMaxIndex: number): Promise<void>;
}
