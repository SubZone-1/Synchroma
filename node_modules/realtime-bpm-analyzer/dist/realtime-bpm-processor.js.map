{
  "version": 3,
  "sources": ["../src/consts.ts", "../src/utils.ts", "../src/analyzer.ts", "../src/realtime-bpm-analyzer.ts", "../processor/realtime-bpm-processor.ts"],
  "sourcesContent": ["export const realtimeBpmProcessorName = 'realtime-bpm-processor';\nexport const startThreshold = 0.95;\nexport const minValidThreshold = 0.3;\nexport const minPeaks = 15;\nexport const thresholdStep = 0.05;\nexport const skipForwardIndexes = 10000;\nexport const offlineLowPassFrequencyValue = 150;\nexport const offlineLowPassQualityValue = 1;\nexport const offlineHighPassFrequencyValue = 100;\nexport const offlineHighPassQualityValue = 1;\n\n", "import * as consts from './consts';\nimport type {Peaks, ValidPeaks, NextIndexPeaks, OnThresholdFunction, AggregateData} from './types';\n\n/**\n * Loop between .9 and minValidThreshold at .3 by default, passoing the threshold to the function\n * @param {OnThresholdFunction} onThreshold Function for each iteration, you must return a boolean, true will exit the loop process\n * @param {number} minValidThreshold minValidThreshold usualy 0.3\n * @param {number} startThreshold startThreshold usualy 0.9\n * @param {number} thresholdStep thresholdStep usuably 0.05\n * @return {Promise<void>}\n */\nexport async function descendingOverThresholds(onThreshold: OnThresholdFunction, minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): Promise<void> {\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    const shouldExit = await onThreshold(threshold);\n    if (shouldExit) {\n      break;\n    }\n  } while (threshold > minValidThreshold);\n}\n\n/**\n * Generate an object with keys as thresholds and will containes validPeaks\n * @param {number} minValidThreshold minValidThreshold usualy 0.3\n * @param {number} startThreshold startThreshold usualy 0.9\n * @param {number} thresholdStep thresholdStep usuably 0.05\n * @return {ValidPeaks} Collection of validPeaks by thresholds\n */\nexport function generateValidPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): ValidPeaks {\n  const object: Record<string, Peaks> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = [];\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\n/**\n * Generate an object with keys as thresholds and will containes NextIndexPeaks\n * @return {NextIndexPeaks} Collection of NextIndexPeaks by thresholds\n */\nexport function generateNextIndexPeaksModel(minValidThreshold = consts.minValidThreshold, startThreshold = consts.startThreshold, thresholdStep = consts.thresholdStep): NextIndexPeaks {\n  const object: Record<string, number> = {};\n  let threshold = startThreshold;\n\n  do {\n    threshold -= thresholdStep;\n    object[threshold.toString()] = 0;\n  } while (threshold > minValidThreshold);\n\n  return object;\n}\n\nexport function chunckAggregator(): (pcmData: Float32Array) => AggregateData {\n  const bufferSize = 4096;\n\n  /**\n   * Track the current buffer fill level\n   */\n  let _bytesWritten = 0;\n\n  /**\n   * Create a buffer of fixed size\n   */\n  let buffer: Float32Array = new Float32Array(0);\n\n  function initBuffer(): void {\n    _bytesWritten = 0;\n    buffer = new Float32Array(0);\n  }\n\n  function isBufferFull(): boolean {\n    return _bytesWritten === bufferSize;\n  }\n\n  function flush(): void {\n    initBuffer();\n  }\n\n  return function (pcmData: Float32Array): AggregateData {\n    if (isBufferFull()) {\n      flush();\n    }\n\n    const newBuffer = new Float32Array(buffer.length + pcmData.length);\n    newBuffer.set(buffer, 0);\n    newBuffer.set(pcmData, buffer.length);\n    buffer = newBuffer;\n    _bytesWritten += pcmData.length;\n\n    return {\n      isBufferFull: isBufferFull(),\n      buffer,\n      bufferSize,\n    };\n  };\n}\n", "import {descendingOverThresholds} from './utils';\nimport type {Peaks, ValidPeaks, PeaksAndThreshold, BpmCandidates, Interval, Tempo, Threshold, Group} from './types';\nimport * as consts from './consts';\n\n/**\n * Find peaks when the signal if greater than the threshold, then move 10_000 indexes (represents ~0.23s) to ignore the descending phase of the parabol\n * @param {Float32Array} data Buffer channel data\n * @param {number} threshold Threshold for qualifying as a peak\n * @param {number} offset Position where we start to loop\n * @param {number} skipForwardIndexes Numbers of index to skip when a peak is detected\n * @return {PeaksAndThreshold} Peaks found that are greater than the threshold\n */\nexport function findPeaksAtThreshold(data: Float32Array, threshold: Threshold, offset = 0, skipForwardIndexes = consts.skipForwardIndexes): PeaksAndThreshold {\n  const peaks: Peaks = [];\n\n  const {length} = data;\n\n  /**\n   * Identify peaks that are greater than the threshold, adding them to the collection\n   */\n  for (let i = offset; i < length; i += 1) {\n    if (data[i] > threshold) {\n      peaks.push(i);\n\n      /**\n       * Skip forward ~0.25s to pass this peak\n       */\n      i += skipForwardIndexes;\n    }\n  }\n\n  return {\n    peaks,\n    threshold,\n  };\n}\n\n/**\n * Find the minimum amount of peaks from top to bottom threshold, it's necessary to analyze at least 10seconds at 90bpm\n * @param {Float32Array} channelData Channel data\n * @returns {Promise<PeaksAndThreshold>} Suffisent amount of peaks in order to continue further the process\n */\nexport async function findPeaks(channelData: Float32Array): Promise<PeaksAndThreshold> {\n  let validPeaks: Peaks = [];\n  let validThreshold = 0;\n\n  await descendingOverThresholds(async threshold => {\n    const {peaks} = findPeaksAtThreshold(channelData, threshold);\n\n    /**\n     * Loop over peaks\n     */\n    if (peaks.length < consts.minPeaks) {\n      return false;\n    }\n\n    validPeaks = peaks;\n    validThreshold = threshold;\n\n    return true;\n  });\n\n  return {\n    peaks: validPeaks,\n    threshold: validThreshold,\n  };\n}\n\n// Type MaxInterval = {\n//   position: number;\n//   volume: number;\n// };\n\n// export function getPeaks(data: Float32Array[], sampleRate: number): MaxInterval[] {\n//   // What we're going to do here, is to divide up our audio into parts.\n\n//   // We will then identify, for each part, what the loudest sample is in that\n//   // part.\n\n//   // It's implied that that sample would represent the most likely 'beat'\n//   // within that part.\n\n//   // Each part is 0.5 seconds long - or 22,050 samples.\n\n//   // This will give us 60 'beats' - we will only take the loudest half of\n//   // those.\n\n//   // This will allow us to ignore breaks, and allow us to address tracks with\n//   // a BPM below 120.\n\n//   // const partSize = 22050;\n//   const partSize = sampleRate / 2;\n//   console.log('partSize, 22050', partSize, 'sampleRate', sampleRate);\n//   const parts = data[0].length / partSize;\n//   let peaks: MaxInterval[] = [];\n\n//   for (let i = 0; i < parts; i++) {\n//     let max: number | MaxInterval = 0;\n//     for (let j = i * partSize; j < (i + 1) * partSize; j++) {\n//       const volume = Math.max(Math.abs(data[0][j]), Math.abs(data[1][j]));\n//       if (typeof max === 'number' || (volume > max.volume)) {\n//         max = {\n//           position: j,\n//           volume,\n//         };\n//       }\n//     }\n\n//     if (typeof max !== 'number') {\n//       peaks.push(max);\n//     }\n//   }\n\n//   // We then sort the peaks according to volume...\n\n//   peaks.sort((a, b) => b.volume - a.volume);\n\n//   // ...take the loundest half of those...\n\n//   peaks = peaks.splice(0, peaks.length * 0.5);\n\n//   // ...and re-sort it back based on position.\n\n//   peaks.sort((a, b) => a.position - b.position);\n\n//   return peaks;\n// }\n\n// export function getIntervals(peaks: MaxInterval[]): Group[] {\n//   // What we now do is get all of our peaks, and then measure the distance to\n//   // other peaks, to create intervals.  Then based on the distance between\n//   // those peaks (the distance of the intervals) we can calculate the BPM of\n//   // that particular interval.\n\n//   // The interval that is seen the most should have the BPM that corresponds\n//   // to the track itself.\n\n//   const groups: Group[] = [];\n\n//   for (let index = 0; index < peaks.length; index++) {\n//     const peak = peaks[index];\n//     for (let i = 1; (index + i) < peaks.length && i < 10; i++) {\n//       const group: Group = {\n//         tempo: (60 * 44100) / (peaks[index + i].position - peak.position),\n//         count: 1,\n//       };\n\n//       while (group.tempo < 90) {\n//         group.tempo *= 2;\n//       }\n\n//       while (group.tempo > 180) {\n//         group.tempo /= 2;\n//       }\n\n//       group.tempo = Math.round(group.tempo);\n\n//       if (!(groups.some(interval => (interval.tempo === group.tempo ? interval.count++ : 0)))) {\n//         groups.push(group);\n//       }\n//     }\n//   }\n\n//   return groups;\n// }\n\n// export function getTop(groups: Group[]): Group[] {\n//   return groups.sort(function(intA, intB) {\n//     return intB.count - intA.count;\n//   }).splice(0, 5);\n// };\n\n// export function getNewAlgorithmBPM(audioBuffer: AudioBuffer) {\n//   const peaks = getPeaks([audioBuffer.getChannelData(0), audioBuffer.getChannelData(1)], audioBuffer.sampleRate);\n//   console.log('peaks', peaks);\n//   const groups = getIntervals(peaks);\n//   console.log('groups', groups);\n//   const tops = getTop(groups);\n//   return tops;\n// }\n\nexport function getBiquadFilters(context: AudioContext | OfflineAudioContext) {\n  const lowpass = context.createBiquadFilter();\n  lowpass.type = 'lowpass';\n  lowpass.frequency.value = consts.offlineLowPassFrequencyValue;\n  lowpass.Q.value = consts.offlineLowPassQualityValue;\n\n  const highpass = context.createBiquadFilter();\n  highpass.type = 'highpass';\n  highpass.frequency.value = consts.offlineHighPassFrequencyValue;\n  highpass.Q.value = consts.offlineHighPassQualityValue;\n\n  return {\n    lowpass,\n    highpass,\n  };\n}\n\n/**\n * Apply to the source a biquad lowpass filter\n * @param {AudioBuffer} buffer Audio buffer\n * @returns {AudioBufferSourceNode}\n */\nexport async function getOfflineLowPassSource(buffer: AudioBuffer): Promise<AudioBuffer> {\n  const {length, numberOfChannels, sampleRate} = buffer;\n  const context = new OfflineAudioContext(numberOfChannels, length, sampleRate);\n\n  /**\n   * Create buffer source\n   */\n  const source = context.createBufferSource();\n  source.buffer = buffer;\n\n  const {lowpass, highpass} = getBiquadFilters(context);\n\n  /**\n   * Pipe the song into the filter, and the filter into the offline context\n   */\n  source.connect(lowpass);\n  source.connect(highpass);\n  lowpass.connect(highpass);\n  highpass.connect(context.destination);\n\n  source.start(0);\n\n  const audioBuffer = await context.startRendering();\n\n  return audioBuffer;\n}\n\n/**\n * Return the computed bpm from data\n * @param {Record<string, number[]>} data Contain valid peaks\n * @param {number} audioSampleRate Audio sample rate\n */\nexport async function computeBpm(data: ValidPeaks, audioSampleRate: number, minPeaks = consts.minPeaks): Promise<BpmCandidates> {\n  /**\n   * Flag to fix Object.keys looping\n   */\n  let hasPeaks = false;\n  let foundThreshold = consts.minValidThreshold;\n\n  await descendingOverThresholds(async (threshold: Threshold) => {\n    if (hasPeaks) {\n      return true;\n    }\n\n    if (data[threshold].length > minPeaks) {\n      hasPeaks = true;\n      foundThreshold = threshold;\n    }\n\n    return false;\n  });\n\n  if (hasPeaks && foundThreshold) {\n    const intervals = identifyIntervals(data[foundThreshold]);\n    const tempos = groupByTempo(audioSampleRate, intervals);\n    const candidates = getTopCandidates(tempos);\n\n    const bpmCandidates: BpmCandidates = {\n      bpm: candidates,\n      threshold: foundThreshold,\n    };\n\n    return bpmCandidates;\n  }\n\n  return {\n    bpm: [],\n    threshold: foundThreshold,\n  };\n}\n\n/**\n * Sort results by count and return top candidate\n * @param {Tempo[]} candidates (BPMs) with count\n * @param {number} length Amount of returned candidates (default: 5)\n * @return {Tempo[]} Returns the 5 top candidates with highest counts\n */\nexport function getTopCandidates(candidates: Tempo[], length = 5): Tempo[] {\n  return candidates.sort((a, b) => (b.count - a.count)).splice(0, length);\n}\n\n/**\n * Gets the top candidate from the array\n * @param {Tempo[]} candidates - (BPMs) with counts.\n * @returns {number} - Returns the top candidate with the highest count.\n */\nexport function getTopCandidate(candidates: Tempo[]): number {\n  if (candidates.length === 0) {\n    throw new Error('Could not find enough samples for a reliable detection.');\n  }\n\n  const [first] = candidates.sort((a, b) => (b.count - a.count));\n\n  return first.tempo;\n}\n\n/**\n * Identify intervals between bass peaks\n * @param {array} peaks Array of qualified bass peaks\n * @return {array} Return a collection of intervals between peaks\n */\nexport function identifyIntervals(peaks: Peaks): Interval[] {\n  const intervals: Interval[] = [];\n\n  for (let n = 0; n < peaks.length; n++) {\n    for (let i = 0; i < 10; i++) {\n      const peak = peaks[n];\n      const peakIndex = n + i;\n      const interval = peaks[peakIndex] - peak;\n\n      /**\n       * Try and find a matching interval and increase it's count\n       */\n      const foundInterval = intervals.some((intervalCount: Interval) => {\n        if (intervalCount.interval === interval) {\n          intervalCount.count += 1;\n          return intervalCount.count;\n        }\n\n        return false;\n      });\n\n      /**\n       * Add the interval to the collection if it's unique\n       */\n      if (!foundInterval) {\n        const item: Interval = {\n          interval,\n          count: 1,\n        };\n        intervals.push(item);\n      }\n    }\n  }\n\n  return intervals;\n}\n\n/**\n * Figure out best possible tempo candidates\n * @param  {number} audioSampleRate Audio sample rate\n * @param  {Interval[]} intervalCounts List of identified intervals\n * @return {Tempo[]} Intervals grouped with similar values\n */\nexport function groupByTempo(audioSampleRate: number, intervalCounts: Interval[]): Tempo[] {\n  const tempoCounts: Tempo[] = [];\n\n  for (const intervalCount of intervalCounts) {\n    /**\n     * Skip if interval is equal 0\n     */\n    if (intervalCount.interval === 0) {\n      continue;\n    }\n\n    intervalCount.interval = Math.abs(intervalCount.interval);\n\n    /**\n     * Convert an interval to tempo\n     */\n    let theoreticalTempo = (60 / (intervalCount.interval / audioSampleRate));\n\n    /**\n     * Adjust the tempo to fit within the 90-180 BPM range\n     */\n    while (theoreticalTempo < 90) {\n      theoreticalTempo *= 2;\n    }\n\n    while (theoreticalTempo > 180) {\n      theoreticalTempo /= 2;\n    }\n\n    /**\n     * Round to legible integer\n     */\n    theoreticalTempo = Math.round(theoreticalTempo);\n\n    /**\n     * See if another interval resolved to the same tempo\n     */\n    const foundTempo: boolean = tempoCounts.some((tempoCount: Tempo) => {\n      if (tempoCount.tempo === theoreticalTempo) {\n        tempoCount.count += intervalCount.count;\n        return tempoCount.count;\n      }\n\n      return false;\n    });\n\n    /**\n     * Add a unique tempo to the collection\n     */\n    if (!foundTempo) {\n      const tempo: Tempo = {\n        tempo: theoreticalTempo,\n        count: intervalCount.count,\n        confidence: 0,\n      };\n\n      tempoCounts.push(tempo);\n    }\n  }\n\n  return tempoCounts;\n}\n\n/**\n * Function to detect the BPM from an AudioBuffer (which can be a whole file)\n * It is the fastest way to detect the BPM\n * @param {AudioBuffer} buffer AudioBuffer\n * @returns {Promise<Tempo[]>} Returns the 5 bests candidates\n */\nexport async function analyzeFullBuffer(buffer: AudioBuffer): Promise<Tempo[]> {\n  const sourceBuffer = await getOfflineLowPassSource(buffer);\n\n  /**\n   * Pipe the source through the program\n   */\n  // const newAlgorithm = getNewAlgorithmBPM(sourceBuffer);\n  // console.log('newAlgorithm', newAlgorithm);\n\n  const channelData = sourceBuffer.getChannelData(0);\n\n  const {peaks} = await findPeaks(channelData);\n  const intervals = identifyIntervals(peaks);\n  const tempos = groupByTempo(buffer.sampleRate, intervals);\n  const topCandidates = getTopCandidates(tempos, channelData.length);\n\n  return topCandidates;\n}\n", "import {findPeaksAtThreshold, computeBpm} from './analyzer';\nimport type {RealTimeBpmAnalyzerOptions, RealTimeBpmAnalyzerParameters, ValidPeaks, NextIndexPeaks, BpmCandidates, Threshold, BpmEventData} from './types';\nimport {generateValidPeaksModel, generateNextIndexPeaksModel, descendingOverThresholds} from './utils';\nimport * as consts from './consts';\n\n/**\n * Initial value of key parameters of the analyzer\n */\nconst initialValue = {\n  minValidThreshold: () => consts.minValidThreshold,\n  timeoutStabilization: () => 0,\n  validPeaks: () => generateValidPeaksModel(),\n  nextIndexPeaks: () => generateNextIndexPeaksModel(),\n  skipIndexes: () => 1,\n};\n\ntype RealtimeBpmAnalyzerAsyncOptions = 'continuousAnalysis' | 'computeBpmDelay' | 'stabilizationTime' | 'muteTimeInIndexes';\n\n/**\n * @class RealTimeBpmAnalyzer\n **/\nexport class RealTimeBpmAnalyzer {\n  /**\n   * Default configuration\n   */\n  options: RealTimeBpmAnalyzerOptions = {\n    continuousAnalysis: false,\n    computeBpmDelay: 10000,\n    stabilizationTime: 20000,\n    muteTimeInIndexes: 10000,\n  };\n\n  /**\n   * Minimum valid threshold, below this level result would be irrelevant.\n   */\n  minValidThreshold: Threshold = initialValue.minValidThreshold();\n  /**\n   * Schedule timeout triggered when the stabilizationTime is reached\n   */\n  timeoutStabilization: number = initialValue.timeoutStabilization();\n  /**\n   * Contain all valid peaks\n   */\n  validPeaks: ValidPeaks = initialValue.validPeaks();\n  /**\n   * Next index (+10000 ...) to take care about peaks\n   */\n  nextIndexPeaks: NextIndexPeaks = initialValue.nextIndexPeaks();\n  /**\n   * Number / Position of chunks\n   */\n  skipIndexes: number = initialValue.skipIndexes();\n\n  /**\n   * @constructor\n   * @param {object} config Configuration\n   * @param {boolean} config.continuousAnalysis Flag indicating if we need to analyze continuously, typically used for streams\n   * @param {number} config.computeBpmDelay Arbitrary delay to compute the BPM for the first time\n   * @param {number} config.stabilizationTime Arbitrary time where we consider that a BPM is computable\n   * @param {number} config.muteTimeInIndexes Arbitrary time to mute the analysis to improve the bpm detection\n   */\n  constructor(config: RealTimeBpmAnalyzerParameters = {}) {\n    /**\n     * Overriding default configuration\n     */\n    Object.assign(this.options, config);\n  }\n\n  /**\n   * Method to apply a configuration on the fly\n   * @param {RealtimeBpmAnalyzerAsyncOptions} key Key of the configuration in this.options\n   * @param {unknown} value The value you need to set\n   * @returns {void}\n   */\n  setAsyncConfiguration(parameters: RealTimeBpmAnalyzerParameters): void {\n    Object.assign(this.options, parameters);\n  }\n\n  /**\n   * Reset BPM computation properties to get a fresh start\n   * @returns {void}\n   */\n  reset(): void {\n    this.minValidThreshold = initialValue.minValidThreshold();\n    this.timeoutStabilization = initialValue.timeoutStabilization();\n    this.validPeaks = initialValue.validPeaks();\n    this.nextIndexPeaks = initialValue.nextIndexPeaks();\n    this.skipIndexes = initialValue.skipIndexes();\n  }\n\n  /**\n   * Remve all validPeaks between the minThreshold pass in param to optimize the weight of datas\n   * @param {Threshold} minThreshold Value between 0.9 and 0.3\n   * @returns {void}\n   */\n  async clearValidPeaks(minThreshold: Threshold): Promise<void> {\n    console.log(`[clearValidPeaks] function: under ${minThreshold}, this.minValidThreshold has been setted to that threshold.`);\n    this.minValidThreshold = Number.parseFloat(minThreshold.toFixed(2));\n\n    await descendingOverThresholds(async threshold => {\n      if (threshold < minThreshold) {\n        delete this.validPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        delete this.nextIndexPeaks[threshold]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n      }\n\n      return false;\n    });\n  }\n\n  /**\n   * Attach this function to an audioprocess event on a audio/video node to compute BPM / Tempo in realtime\n   * @param {Float32Array} channelData Channel data\n   * @param {number} audioSampleRate Audio sample rate\n   * @param {number} bufferSize Buffer size\n   * @param {(data: any) => void} postMessage Function to post a message to the processor node\n   * @returns {Promise<void>}\n   */\n  async analyzeChunck(channelData: Float32Array, audioSampleRate: number, bufferSize: number, postMessage: (data: BpmEventData) => void): Promise<void> {\n    /**\n     * Compute the maximum index with all previous chunks\n     */\n    const currentMaxIndex = bufferSize * this.skipIndexes;\n\n    /**\n     * Compute the minimum index with all previous chunks\n     */\n    const currentMinIndex = currentMaxIndex - bufferSize;\n\n    /**\n     * Mutate nextIndexPeaks and validPeaks if possible\n     */\n    await this.findPeaks(channelData, bufferSize, currentMinIndex, currentMaxIndex);\n\n    /**\n     * Increment chunk\n     */\n    this.skipIndexes++;\n\n    const result: BpmCandidates = await computeBpm(this.validPeaks, audioSampleRate);\n    const {threshold} = result;\n    postMessage({message: 'BPM', result});\n\n    if (this.minValidThreshold < threshold) {\n      postMessage({message: 'BPM_STABLE', result});\n      await this.clearValidPeaks(threshold);\n    }\n\n    /**\n     * After x milliseconds, we reinit the analyzer\n     */\n    if (this.options.continuousAnalysis) {\n      clearTimeout(this.timeoutStabilization);\n      this.timeoutStabilization = window.setTimeout(() => {\n        console.log('[timeoutStabilization] setTimeout: Fired !');\n        this.options.computeBpmDelay = 0;\n        this.reset();\n      }, this.options.stabilizationTime);\n    }\n  }\n\n  /**\n   * Find the best threshold with enought peaks\n   * @param {Float32Array} channelData Channel data\n   * @param {number} bufferSize Buffer size\n   * @param {number} currentMinIndex Current minimum index\n   * @param {number} currentMaxIndex Current maximum index\n   * @returns {void}\n   */\n  async findPeaks(channelData: Float32Array, bufferSize: number, currentMinIndex: number, currentMaxIndex: number): Promise<void> {\n    await descendingOverThresholds(async threshold => {\n      if (this.nextIndexPeaks[threshold] >= currentMaxIndex) {\n        return false;\n      }\n\n      /**\n       * Get the next index in the next chunk\n       */\n      const offsetForNextPeak = this.nextIndexPeaks[threshold] % bufferSize; // 0 - 4095\n\n      const {peaks, threshold: atThreshold} = findPeaksAtThreshold(channelData, threshold, offsetForNextPeak);\n\n      /**\n       * Loop over peaks\n       */\n      if (peaks.length === 0) {\n        return false;\n      }\n\n      for (const relativeChunkPeak of peaks) {\n        /**\n         * Add current Index + muteTimeInIndexes (10000/44100=0.22s)\n         */\n        this.nextIndexPeaks[atThreshold] = currentMinIndex + relativeChunkPeak + this.options.muteTimeInIndexes;\n\n        /**\n         * Store valid relativeChunkPeak Indexes\n         */\n        this.validPeaks[atThreshold].push(currentMinIndex + relativeChunkPeak);\n      }\n\n      return false;\n    }, this.minValidThreshold);\n  }\n}\n", "import {realtimeBpmProcessorName} from '../src/consts';\nimport {chunckAggregator} from '../src/utils';\nimport {RealTimeBpmAnalyzer} from '../src/realtime-bpm-analyzer';\nimport type {AsyncConfigurationEvent, AggregateData} from '../src/types';\n\n/**\n * Those declaration are from the package @types/audioworklet. But it is not compatible with the lib 'dom'.\n */\n/* eslint-disable no-var, @typescript-eslint/prefer-function-type, @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention */\ndeclare var sampleRate: number;\n\ninterface AudioWorkletProcessor {\n  readonly port: MessagePort;\n}\n\ndeclare var AudioWorkletProcessor: {\n  prototype: AudioWorkletProcessor;\n  new(): AudioWorkletProcessor;\n};\n\ninterface AudioWorkletProcessorImpl extends AudioWorkletProcessor {\n  process(inputs: Float32Array[][], outputs: Float32Array[][], parameters: Record<string, Float32Array>): boolean;\n}\n\ninterface WorkletGlobalScope {}\n\ndeclare var WorkletGlobalScope: {\n  prototype: WorkletGlobalScope;\n  new(): WorkletGlobalScope;\n};\n\ninterface AudioWorkletGlobalScope extends WorkletGlobalScope {\n  readonly currentFrame: number;\n  readonly currentTime: number;\n  readonly sampleRate: number;\n  registerProcessor(name: string, processorCtor: AudioWorkletProcessorConstructor): void;\n}\n\ndeclare var AudioWorkletGlobalScope: {\n  prototype: AudioWorkletGlobalScope;\n  new(): AudioWorkletGlobalScope;\n};\n\ninterface AudioWorkletProcessorConstructor {\n  new (options: any): AudioWorkletProcessorImpl;\n}\n\ndeclare function registerProcessor(name: string, processorCtor: AudioWorkletProcessorConstructor): void;\n/* eslint-enable no-var, @typescript-eslint/prefer-function-type, @typescript-eslint/no-empty-interface, @typescript-eslint/consistent-type-definitions, @typescript-eslint/no-redeclare, @typescript-eslint/naming-convention */\n\n/**\n * @class RealTimeBpmProcessor\n * @extends AudioWorkletProcessor\n **/\nexport class RealTimeBpmProcessor extends AudioWorkletProcessor {\n  aggregate: (pcmData: Float32Array) => AggregateData;\n  realTimeBpmAnalyzer: RealTimeBpmAnalyzer = new RealTimeBpmAnalyzer();\n\n  constructor() {\n    super();\n\n    this.aggregate = chunckAggregator();\n\n    this.port.addEventListener('message', this.onMessage.bind(this));\n    this.port.start();\n  }\n\n  /**\n   * Handle message event\n   * @param {object} event Contain event data from main process\n   * @returns {void}\n   */\n  onMessage(event: AsyncConfigurationEvent): void {\n    // Handle custom event ASYNC_CONFIGURATION, to set configuration asynchronously\n    if (event.data.message === 'ASYNC_CONFIGURATION') {\n      this.realTimeBpmAnalyzer.setAsyncConfiguration(event.data.parameters);\n    }\n  }\n\n  /**\n   * Process function to handle chunks of data\n   * @param {Float32Array[][]} inputs Inputs (the data we need to process)\n   * @param {Float32Array[][]} _outputs Outputs (not useful for now)\n   * @param {Record<string, Float32Array>} _parameters Parameters\n   * @returns {boolean} Process ended successfully\n   */\n  process(inputs: Float32Array[][], _outputs: Float32Array[][], _parameters: Record<string, Float32Array>): boolean {\n    const currentChunk = inputs[0][0];\n\n    if (!currentChunk) {\n      return true;\n    }\n\n    const {isBufferFull, buffer, bufferSize} = this.aggregate(currentChunk);\n\n    if (isBufferFull) {\n      // The variable sampleRate is global ! thanks to the AudioWorkletProcessor\n      this.realTimeBpmAnalyzer.analyzeChunck(buffer, sampleRate, bufferSize, event => {\n        this.port.postMessage(event);\n      }).catch((error: unknown) => {\n        console.error(error);\n      });\n    }\n\n    return true;\n  }\n}\n\n/**\n * Mandatory Registration to use the processor\n */\nregisterProcessor(realtimeBpmProcessorName, RealTimeBpmProcessor);\n\nexport default {};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;AAAO,MAAM,2BAA2B;AACjC,MAAM,iBAAiB;AACvB,MAAM,oBAAoB;AAC1B,MAAM,WAAW;AACjB,MAAM,gBAAgB;AACtB,MAAM,qBAAqB;;;ACMlC,WAAsB,yBAAyB,IAA6K;AAAA,+CAA7K,aAAkCA,qBAA2B,mBAAmBC,kBAAwB,gBAAgBC,iBAAuB,eAA8B;AAC1N,UAAI,YAAYD;AAEhB,SAAG;AACD,qBAAaC;AACb,cAAM,aAAa,MAAM,YAAY,SAAS;AAC9C,YAAI,YAAY;AACd;AAAA,QACF;AAAA,MACF,SAAS,YAAYF;AAAA,IACvB;AAAA;AASO,WAAS,wBAAwBA,qBAA2B,mBAAmBC,kBAAwB,gBAAgBC,iBAAuB,eAA2B;AAC9K,UAAM,SAAgC,CAAC;AACvC,QAAI,YAAYD;AAEhB,OAAG;AACD,mBAAaC;AACb,aAAO,UAAU,SAAS,KAAK,CAAC;AAAA,IAClC,SAAS,YAAYF;AAErB,WAAO;AAAA,EACT;AAMO,WAAS,4BAA4BA,qBAA2B,mBAAmBC,kBAAwB,gBAAgBC,iBAAuB,eAA+B;AACtL,UAAM,SAAiC,CAAC;AACxC,QAAI,YAAYD;AAEhB,OAAG;AACD,mBAAaC;AACb,aAAO,UAAU,SAAS,KAAK;AAAA,IACjC,SAAS,YAAYF;AAErB,WAAO;AAAA,EACT;AAEO,WAAS,mBAA6D;AAC3E,UAAM,aAAa;AAKnB,QAAI,gBAAgB;AAKpB,QAAI,SAAuB,IAAI,aAAa,CAAC;AAE7C,aAAS,aAAmB;AAC1B,sBAAgB;AAChB,eAAS,IAAI,aAAa,CAAC;AAAA,IAC7B;AAEA,aAAS,eAAwB;AAC/B,aAAO,kBAAkB;AAAA,IAC3B;AAEA,aAAS,QAAc;AACrB,iBAAW;AAAA,IACb;AAEA,WAAO,SAAU,SAAsC;AACrD,UAAI,aAAa,GAAG;AAClB,cAAM;AAAA,MACR;AAEA,YAAM,YAAY,IAAI,aAAa,OAAO,SAAS,QAAQ,MAAM;AACjE,gBAAU,IAAI,QAAQ,CAAC;AACvB,gBAAU,IAAI,SAAS,OAAO,MAAM;AACpC,eAAS;AACT,uBAAiB,QAAQ;AAEzB,aAAO;AAAA,QACL,cAAc,aAAa;AAAA,QAC3B;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;;;ACzFO,WAAS,qBAAqB,MAAoB,WAAsB,SAAS,GAAGG,sBAA4B,oBAAuC;AAC5J,UAAM,QAAe,CAAC;AAEtB,UAAM,EAAC,OAAM,IAAI;AAKjB,aAAS,IAAI,QAAQ,IAAI,QAAQ,KAAK,GAAG;AACvC,UAAI,KAAK,KAAK,WAAW;AACvB,cAAM,KAAK,CAAC;AAKZ,aAAKA;AAAA,MACP;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAwMA,WAAsB,WAAW,IAAkB,IAA6E;AAAA,+CAA/F,MAAkB,iBAAyBC,YAAkB,UAAkC;AAI9H,UAAI,WAAW;AACf,UAAI,iBAAwB;AAE5B,YAAM,yBAAyB,CAAO,cAAyB;AAC7D,YAAI,UAAU;AACZ,iBAAO;AAAA,QACT;AAEA,YAAI,KAAK,WAAW,SAASA,WAAU;AACrC,qBAAW;AACX,2BAAiB;AAAA,QACnB;AAEA,eAAO;AAAA,MACT,EAAC;AAED,UAAI,YAAY,gBAAgB;AAC9B,cAAM,YAAY,kBAAkB,KAAK,eAAe;AACxD,cAAM,SAAS,aAAa,iBAAiB,SAAS;AACtD,cAAM,aAAa,iBAAiB,MAAM;AAE1C,cAAM,gBAA+B;AAAA,UACnC,KAAK;AAAA,UACL,WAAW;AAAA,QACb;AAEA,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,QACL,KAAK,CAAC;AAAA,QACN,WAAW;AAAA,MACb;AAAA,IACF;AAAA;AAQO,WAAS,iBAAiB,YAAqB,SAAS,GAAY;AACzE,WAAO,WAAW,KAAK,CAAC,GAAG,MAAO,EAAE,QAAQ,EAAE,KAAM,EAAE,OAAO,GAAG,MAAM;AAAA,EACxE;AAsBO,WAAS,kBAAkB,OAA0B;AAC1D,UAAM,YAAwB,CAAC;AAE/B,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,eAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,cAAM,OAAO,MAAM;AACnB,cAAM,YAAY,IAAI;AACtB,cAAM,WAAW,MAAM,aAAa;AAKpC,cAAM,gBAAgB,UAAU,KAAK,CAAC,kBAA4B;AAChE,cAAI,cAAc,aAAa,UAAU;AACvC,0BAAc,SAAS;AACvB,mBAAO,cAAc;AAAA,UACvB;AAEA,iBAAO;AAAA,QACT,CAAC;AAKD,YAAI,CAAC,eAAe;AAClB,gBAAM,OAAiB;AAAA,YACrB;AAAA,YACA,OAAO;AAAA,UACT;AACA,oBAAU,KAAK,IAAI;AAAA,QACrB;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAQO,WAAS,aAAa,iBAAyB,gBAAqC;AACzF,UAAM,cAAuB,CAAC;AAE9B,eAAW,iBAAiB,gBAAgB;AAI1C,UAAI,cAAc,aAAa,GAAG;AAChC;AAAA,MACF;AAEA,oBAAc,WAAW,KAAK,IAAI,cAAc,QAAQ;AAKxD,UAAI,mBAAoB,MAAM,cAAc,WAAW;AAKvD,aAAO,mBAAmB,IAAI;AAC5B,4BAAoB;AAAA,MACtB;AAEA,aAAO,mBAAmB,KAAK;AAC7B,4BAAoB;AAAA,MACtB;AAKA,yBAAmB,KAAK,MAAM,gBAAgB;AAK9C,YAAM,aAAsB,YAAY,KAAK,CAAC,eAAsB;AAClE,YAAI,WAAW,UAAU,kBAAkB;AACzC,qBAAW,SAAS,cAAc;AAClC,iBAAO,WAAW;AAAA,QACpB;AAEA,eAAO;AAAA,MACT,CAAC;AAKD,UAAI,CAAC,YAAY;AACf,cAAM,QAAe;AAAA,UACnB,OAAO;AAAA,UACP,OAAO,cAAc;AAAA,UACrB,YAAY;AAAA,QACd;AAEA,oBAAY,KAAK,KAAK;AAAA,MACxB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;;;AChZA,MAAM,eAAe;AAAA,IACnB,mBAAmB,MAAa;AAAA,IAChC,sBAAsB,MAAM;AAAA,IAC5B,YAAY,MAAM,wBAAwB;AAAA,IAC1C,gBAAgB,MAAM,4BAA4B;AAAA,IAClD,aAAa,MAAM;AAAA,EACrB;AAOO,MAAM,sBAAN,MAA0B;AAAA,IAwC/B,YAAY,SAAwC,CAAC,GAAG;AApCxD,qBAAsC;AAAA,QACpC,oBAAoB;AAAA,QACpB,iBAAiB;AAAA,QACjB,mBAAmB;AAAA,QACnB,mBAAmB;AAAA,MACrB;AAKA,+BAA+B,aAAa,kBAAkB;AAI9D,kCAA+B,aAAa,qBAAqB;AAIjE,wBAAyB,aAAa,WAAW;AAIjD,4BAAiC,aAAa,eAAe;AAI7D,yBAAsB,aAAa,YAAY;AAc7C,aAAO,OAAO,KAAK,SAAS,MAAM;AAAA,IACpC;AAAA,IAQA,sBAAsB,YAAiD;AACrE,aAAO,OAAO,KAAK,SAAS,UAAU;AAAA,IACxC;AAAA,IAMA,QAAc;AACZ,WAAK,oBAAoB,aAAa,kBAAkB;AACxD,WAAK,uBAAuB,aAAa,qBAAqB;AAC9D,WAAK,aAAa,aAAa,WAAW;AAC1C,WAAK,iBAAiB,aAAa,eAAe;AAClD,WAAK,cAAc,aAAa,YAAY;AAAA,IAC9C;AAAA,IAOM,gBAAgB,cAAwC;AAAA;AAC5D,gBAAQ,IAAI,qCAAqC,yEAAyE;AAC1H,aAAK,oBAAoB,OAAO,WAAW,aAAa,QAAQ,CAAC,CAAC;AAElE,cAAM,yBAAyB,CAAM,cAAa;AAChD,cAAI,YAAY,cAAc;AAC5B,mBAAO,KAAK,WAAW;AACvB,mBAAO,KAAK,eAAe;AAAA,UAC7B;AAEA,iBAAO;AAAA,QACT,EAAC;AAAA,MACH;AAAA;AAAA,IAUM,cAAc,aAA2B,iBAAyB,YAAoB,aAA0D;AAAA;AAIpJ,cAAM,kBAAkB,aAAa,KAAK;AAK1C,cAAM,kBAAkB,kBAAkB;AAK1C,cAAM,KAAK,UAAU,aAAa,YAAY,iBAAiB,eAAe;AAK9E,aAAK;AAEL,cAAM,SAAwB,MAAM,WAAW,KAAK,YAAY,eAAe;AAC/E,cAAM,EAAC,UAAS,IAAI;AACpB,oBAAY,EAAC,SAAS,OAAO,OAAM,CAAC;AAEpC,YAAI,KAAK,oBAAoB,WAAW;AACtC,sBAAY,EAAC,SAAS,cAAc,OAAM,CAAC;AAC3C,gBAAM,KAAK,gBAAgB,SAAS;AAAA,QACtC;AAKA,YAAI,KAAK,QAAQ,oBAAoB;AACnC,uBAAa,KAAK,oBAAoB;AACtC,eAAK,uBAAuB,OAAO,WAAW,MAAM;AAClD,oBAAQ,IAAI,4CAA4C;AACxD,iBAAK,QAAQ,kBAAkB;AAC/B,iBAAK,MAAM;AAAA,UACb,GAAG,KAAK,QAAQ,iBAAiB;AAAA,QACnC;AAAA,MACF;AAAA;AAAA,IAUM,UAAU,aAA2B,YAAoB,iBAAyB,iBAAwC;AAAA;AAC9H,cAAM,yBAAyB,CAAM,cAAa;AAChD,cAAI,KAAK,eAAe,cAAc,iBAAiB;AACrD,mBAAO;AAAA,UACT;AAKA,gBAAM,oBAAoB,KAAK,eAAe,aAAa;AAE3D,gBAAM,EAAC,OAAO,WAAW,YAAW,IAAI,qBAAqB,aAAa,WAAW,iBAAiB;AAKtG,cAAI,MAAM,WAAW,GAAG;AACtB,mBAAO;AAAA,UACT;AAEA,qBAAW,qBAAqB,OAAO;AAIrC,iBAAK,eAAe,eAAe,kBAAkB,oBAAoB,KAAK,QAAQ;AAKtF,iBAAK,WAAW,aAAa,KAAK,kBAAkB,iBAAiB;AAAA,UACvE;AAEA,iBAAO;AAAA,QACT,IAAG,KAAK,iBAAiB;AAAA,MAC3B;AAAA;AAAA,EACF;;;ACrJO,MAAM,uBAAN,cAAmC,sBAAsB;AAAA,IAI9D,cAAc;AACZ,YAAM;AAHR,iCAA2C,IAAI,oBAAoB;AAKjE,WAAK,YAAY,iBAAiB;AAElC,WAAK,KAAK,iBAAiB,WAAW,KAAK,UAAU,KAAK,IAAI,CAAC;AAC/D,WAAK,KAAK,MAAM;AAAA,IAClB;AAAA,IAOA,UAAU,OAAsC;AAE9C,UAAI,MAAM,KAAK,YAAY,uBAAuB;AAChD,aAAK,oBAAoB,sBAAsB,MAAM,KAAK,UAAU;AAAA,MACtE;AAAA,IACF;AAAA,IASA,QAAQ,QAA0B,UAA4B,aAAoD;AAChH,YAAM,eAAe,OAAO,GAAG;AAE/B,UAAI,CAAC,cAAc;AACjB,eAAO;AAAA,MACT;AAEA,YAAM,EAAC,cAAc,QAAQ,WAAU,IAAI,KAAK,UAAU,YAAY;AAEtE,UAAI,cAAc;AAEhB,aAAK,oBAAoB,cAAc,QAAQ,YAAY,YAAY,WAAS;AAC9E,eAAK,KAAK,YAAY,KAAK;AAAA,QAC7B,CAAC,EAAE,MAAM,CAAC,UAAmB;AAC3B,kBAAQ,MAAM,KAAK;AAAA,QACrB,CAAC;AAAA,MACH;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AAKA,oBAAkB,0BAA0B,oBAAoB;AAEhE,MAAO,iCAAQ,CAAC;",
  "names": ["minValidThreshold", "startThreshold", "thresholdStep", "skipForwardIndexes", "minPeaks"]
}
